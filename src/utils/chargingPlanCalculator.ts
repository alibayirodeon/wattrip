import { Vehicle } from '../context/useVehicleStore';
import { ChargingStation } from '../services/chargingStationService';
import { EnergyCalculator, generateBatteryWarnings, calculateTripStats, formatDuration, SegmentSOC } from '../lib/energyUtils';

// Haversine formula - iki koordinat arasƒ± mesafe hesaplama (km)
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Earth radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// ≈ûarj istasyonu g√º√ß kategorisi belirleme
function getStationPowerCategory(station: ChargingStation): 'ultra' | 'fast' | 'medium' | 'slow' {
  const maxPower = Math.max(...(station.Connections?.map(conn => conn.PowerKW || 0) || [0]));
  
  if (maxPower >= 150) return 'ultra'; // 150kW+ (Ultra hƒ±zlƒ±)
  if (maxPower >= 50) return 'fast';   // 50-149kW (Hƒ±zlƒ± DC)
  if (maxPower >= 22) return 'medium'; // 22-49kW (Orta AC/DC)
  return 'slow';                       // <22kW (Yava≈ü AC)
}

// Connector type uyumluluƒüu kontrol et - daha gev≈üek kriter
function isStationCompatible(station: ChargingStation, vehicleSocketType: string): boolean {
  if (!station.Connections || station.Connections.length === 0) {
    return true; // Baƒülantƒ± bilgisi yoksa kabul et (g√ºvenli taraf)
  }
  
  return station.Connections.some(connection => {
    const connectionTitle = connection.ConnectionType?.Title?.toLowerCase() || '';
    const formalName = connection.ConnectionType?.FormalName?.toLowerCase() || '';
    const powerKW = connection.PowerKW || 0;
    
    // DC Fast Charging stations genelde uyumludur
    if (powerKW >= 50) {
      return true; // 50kW+ istasyonlar genelde CCS/CHAdeMO destekler
    }
    
    switch (vehicleSocketType) {
      case 'CCS':
        return connectionTitle.includes('ccs') || 
               connectionTitle.includes('combo') ||
               connectionTitle.includes('dc') ||
               formalName.includes('combined charging system') ||
               formalName.includes('combo');
      case 'Type2':
        return connectionTitle.includes('type 2') || 
               connectionTitle.includes('type2') ||
               connectionTitle.includes('mennekes') ||
               formalName.includes('mennekes');
      case 'CHAdeMO':
        return connectionTitle.includes('chademo');
      default:
        return true; // Bilinmeyen socket type'lar i√ßin kabul et
    }
  });
}

// ƒ∞stasyon skoru hesaplama (location, power, compatibility)
function calculateStationScore(
  station: ChargingStation, 
  targetLat: number, 
  targetLon: number,
  vehicleSocketType: string
): number {
  let score = 0;
  
  // 1. Mesafe skoru (yakƒ±n istasyonlar daha y√ºksek skor) - daha gev≈üek limit
  const distance = calculateDistance(
    station.AddressInfo?.Latitude || 0,
    station.AddressInfo?.Longitude || 0,
    targetLat,
    targetLon
  );
  const distanceScore = Math.max(0, 100 - distance); // 100km'den yakƒ±n olanlar puan alƒ±r (daha gev≈üek)
  score += distanceScore;
  
  // 2. G√º√ß skoru (y√ºksek g√º√ß daha y√ºksek skor)
  const powerCategory = getStationPowerCategory(station);
  const powerScore = {
    'ultra': 100,
    'fast': 75,
    'medium': 50,
    'slow': 25
  }[powerCategory];
  score += powerScore;
  
  // 3. Uyumluluk skoru
  if (isStationCompatible(station, vehicleSocketType)) {
    score += 50; // Uyumlu connector type i√ßin bonus
  }
  
  // 4. Operational durumu skoru
  if (station.StatusType?.IsOperational) {
    score += 25;
  }
  
  return score;
}

export interface ChargingStop {
  stationId: number;
  name: string;
  stopCoord: { latitude: number; longitude: number };
  distanceFromStartKm: number;
  batteryBeforeStopPercent: number;
  batteryAfterStopPercent: number;
  energyChargedKWh: number;
  estimatedChargeTimeMinutes: number;
  stationPowerKW: number;
  averageChargingPowerKW: number; // Ger√ßek ortalama ≈üarj g√ºc√º
  connectorType: string;
  chargingEfficiency: number; // ≈ûarj verimliliƒüi %
  segmentInfo?: {
    segmentIndex: number;
    distanceToNext?: number;
    batteryAtSegmentEnd?: number;
  };
}

export interface RouteData {
  distance: number; // meters
  polylinePoints: Array<{ latitude: number; longitude: number }>;
}

export interface ChargingPlanResult {
  chargingStops: ChargingStop[];
  totalChargingTimeMinutes: number;
  canReachDestination: boolean;
  batteryAtDestinationPercent: number;
  totalEnergyConsumedKWh: number;
  warnings: string[];
  segmentDetails: SegmentSOC[]; // Segment bazlƒ± SOC detaylarƒ±
  chargingEfficiencyStats: {
    averageChargingPower: number;
    totalEnergyCharged: number;
    chargingEfficiency: number;
  };
}

/**
 * üîã EV ≈ûarj Planlama Algoritmasƒ±
 * 
 * Ara√ß √∂zelliklerine ve rota bilgilerine g√∂re optimal ≈üarj planƒ± olu≈üturur
 */
export function generateChargingPlan({
  selectedVehicle,
  routeData,
  chargingStations
}: {
  selectedVehicle: Vehicle;
  routeData: RouteData;
  chargingStations: ChargingStation[];
}): ChargingPlanResult {
  console.log('üßÆ ≈ûarj planƒ± hesaplama ba≈üladƒ±...', {
    vehicle: `${selectedVehicle.brand} ${selectedVehicle.model}`,
    batteryCapacity: `${selectedVehicle.batteryCapacity}kWh`,
    consumption: `${selectedVehicle.consumption}kWh/100km`,
    routeDistance: `${(routeData.distance / 1000).toFixed(1)}km`,
    availableStations: chargingStations.length
  });
  
  // üîã Energy calculator instance olu≈ütur
  const energyCalc = new EnergyCalculator(
    selectedVehicle.batteryCapacity,
    selectedVehicle.consumption
  );
  
  const warnings: string[] = [];
  const chargingStops: ChargingStop[] = [];
  
  // [1] üìä Temel hesaplamalar
  const routeDistanceKm = routeData.distance / 1000;
  const totalEnergyNeededKWh = energyCalc.distanceToEnergyConsumption(routeDistanceKm);
  const maxRangeKm = energyCalc.socToRange(100);
  
  // Ba≈ülangƒ±√ß ve hedef batarya seviyeleri (ABRP tarzƒ±)
  const startChargePercent = 85; // %85 ile ba≈üla (daha ger√ßek√ßi)
  const targetArrivalPercent = 15; // %15 ile bitir (g√ºvenlik marjƒ±)
  const maxChargePercent = 85; // Maksimum %85'e kadar ≈üarj et (hƒ±z i√ßin)
  const safetyMarginPercent = 15; // %15 g√ºvenlik marjƒ± (daha g√ºvenli)
  
  console.log('üìà Enerji hesaplamalarƒ±:', {
    totalEnergyNeeded: `${totalEnergyNeededKWh.toFixed(1)}kWh`,
    maxRange: `${maxRangeKm.toFixed(1)}km`,
    startBattery: `${startChargePercent}%`,
    targetArrival: `${targetArrivalPercent}%`
  });
  
  // [2] üîã Mevcut durum deƒüerlendirme
  let currentBatteryPercent = startChargePercent;
  let currentBatteryKWh = (currentBatteryPercent / 100) * selectedVehicle.batteryCapacity;
  let currentRangeKm = (currentBatteryKWh * 100) / selectedVehicle.consumption;
  let remainingDistanceKm = routeDistanceKm;
  let traveledDistanceKm = 0;
  
  // [3] üéØ ƒ∞lk kontrol - tek seferde gidebilir mi?
  const canReachDirectly = currentRangeKm >= (routeDistanceKm + (routeDistanceKm * safetyMarginPercent / 100));
  
  if (canReachDirectly) {
    const batteryAtDestination = currentBatteryPercent - (totalEnergyNeededKWh / selectedVehicle.batteryCapacity * 100);
    console.log('‚úÖ Tek seferde ula≈üƒ±m m√ºmk√ºn:', {
      currentRange: `${currentRangeKm.toFixed(1)}km`,
      neededRange: `${routeDistanceKm.toFixed(1)}km`,
      batteryAtDestination: `${batteryAtDestination.toFixed(1)}%`
    });
    
    return {
      chargingStops: [],
      totalChargingTimeMinutes: 0,
      canReachDestination: true,
      batteryAtDestinationPercent: Math.round(batteryAtDestination),
      totalEnergyConsumedKWh: totalEnergyNeededKWh,
      warnings: batteryAtDestination < targetArrivalPercent ? 
        [`Hedefteki batarya seviyesi (${batteryAtDestination.toFixed(1)}%) hedef seviyenin (${targetArrivalPercent}%) altƒ±nda olacak`] : [],
      segmentDetails: [],
      chargingEfficiencyStats: {
        averageChargingPower: 0,
        totalEnergyCharged: 0,
        chargingEfficiency: 0
      }
    };
  }
  
  // [4] üõ£Ô∏è ≈ûarj duraklarƒ± planlama
  console.log('üîå ≈ûarj duraklarƒ± planlama gerekli...');
  
  const usedStationIds = new Set<number>();
  let segmentIndex = 0;
  const maxAttempts = 10; // Sonsuz d√∂ng√º √∂nleme
  
  while (remainingDistanceKm > 0 && segmentIndex < maxAttempts) {
    // Mevcut menzille gidebileceƒüi maksimum mesafe
    const safeRangeKm = currentRangeKm * (1 - safetyMarginPercent / 100);
    const segmentDistanceKm = Math.min(safeRangeKm, remainingDistanceKm);
    
    console.log(`üìç Segment ${segmentIndex + 1}:`, {
      currentBattery: `${currentBatteryPercent.toFixed(1)}%`,
      currentRange: `${currentRangeKm.toFixed(1)}km`,
      safeRange: `${safeRangeKm.toFixed(1)}km`,
      remainingDistance: `${remainingDistanceKm.toFixed(1)}km`,
      plannedSegment: `${segmentDistanceKm.toFixed(1)}km`
    });
    
    // Bu segmentten sonra ≈üarj gerekli mi?
    const energyAfterSegment = currentBatteryKWh - (segmentDistanceKm * selectedVehicle.consumption / 100);
    const batteryAfterSegment = (energyAfterSegment / selectedVehicle.batteryCapacity) * 100;
    const rangeAfterSegment = (energyAfterSegment * 100) / selectedVehicle.consumption;
    
    traveledDistanceKm += segmentDistanceKm;
    remainingDistanceKm -= segmentDistanceKm;
    
    // Segment tamamlandƒ±ktan sonra durum g√ºncelle
    currentBatteryKWh = energyAfterSegment;
    currentBatteryPercent = batteryAfterSegment;
    currentRangeKm = rangeAfterSegment;
    
    // Hedefe ula≈ütƒ±k mƒ±?
    if (remainingDistanceKm <= 0) {
      console.log('üèÅ Hedefe ula≈üƒ±ldƒ±:', {
        finalBattery: `${currentBatteryPercent.toFixed(1)}%`,
        targetArrival: `${targetArrivalPercent}%`
      });
      break;
    }
    
    // ≈ûarj gerekli mi kontrol et
    const safetyRangeForNext = remainingDistanceKm * (1 + safetyMarginPercent / 100);
    
    if (currentRangeKm < safetyRangeForNext) {
      console.log(`üîã ≈ûarj gerekli: Mevcut menzil ${currentRangeKm.toFixed(1)}km, gerekli ${safetyRangeForNext.toFixed(1)}km`);
      
      // [5] üéØ En yakƒ±n uygun istasyonu bul
      const currentPosition = routeData.polylinePoints[Math.floor((traveledDistanceKm / routeDistanceKm) * routeData.polylinePoints.length)] || 
                             routeData.polylinePoints[0];
      
      // Uygun istasyonlarƒ± filtrele ve skorla
      console.log(`üîç ƒ∞stasyon filtreleme ba≈ülƒ±yor: ${chargingStations.length} toplam istasyon`);
      
      const notUsedStations = chargingStations.filter(station => !usedStationIds.has(station.ID));
      console.log(`‚ö° Kullanƒ±lmamƒ±≈ü istasyonlar: ${notUsedStations.length}`);
      
      const compatibleStations = notUsedStations.filter(station => isStationCompatible(station, selectedVehicle.socketType));
      console.log(`üîå Uyumlu istasyonlar: ${compatibleStations.length} (Socket: ${selectedVehicle.socketType})`);
      
      const availableStations = compatibleStations
        .map(station => ({
          station,
          score: calculateStationScore(
            station,
            currentPosition.latitude,
            currentPosition.longitude,
            selectedVehicle.socketType
          ),
          distance: calculateDistance(
            station.AddressInfo?.Latitude || 0,
            station.AddressInfo?.Longitude || 0,
            currentPosition.latitude,
            currentPosition.longitude
          )
        }))
        .sort((a, b) => b.score - a.score); // En y√ºksek skordan d√º≈ü√ºƒüe sƒ±rala
      
      console.log(`üìä Skorlanmƒ±≈ü istasyonlar: ${availableStations.length}`);
      if (availableStations.length > 0) {
        console.log(`üèÜ En iyi 3 istasyon:`, availableStations.slice(0, 3).map(s => 
          `${s.station.AddressInfo?.Title} (Skor: ${s.score.toFixed(1)}, Mesafe: ${s.distance.toFixed(1)}km)`
        ));
      }
      
      if (availableStations.length === 0) {
        warnings.push('Uygun ≈üarj istasyonu bulunamadƒ±! Alternatif rota √∂nerilir.');
        console.log('‚ùå Uygun ≈üarj istasyonu bulunamadƒ±');
        break;
      }
      
      const bestStation = availableStations[0];
      console.log(`üéØ En iyi istasyon se√ßildi: ${bestStation.station.AddressInfo?.Title} (Skor: ${bestStation.score.toFixed(1)}, Mesafe: ${bestStation.distance.toFixed(1)}km)`);
      
      // [6] ‚ö° ≈ûarj miktarƒ± ve s√ºresi hesapla
      const stationPowerKW = Math.max(...(bestStation.station.Connections?.map(conn => conn.PowerKW || 0) || [0]));
      
      // Hedef ≈üarj seviyesi hesapla
      const neededRangeKm = remainingDistanceKm * (1 + safetyMarginPercent / 100);
      const neededEnergyKWh = (neededRangeKm * selectedVehicle.consumption) / 100;
      const neededBatteryPercent = (neededEnergyKWh / selectedVehicle.batteryCapacity) * 100;
      
      const targetChargePercent = Math.min(
        maxChargePercent,
        Math.max(
          currentBatteryPercent + neededBatteryPercent,
          80 // Minimum %80'e ≈üarj et
        )
      );
      
      const energyToChargeKWh = ((targetChargePercent - currentBatteryPercent) / 100) * selectedVehicle.batteryCapacity;
      const chargingResult = calculateAdvancedChargeTime(
        energyCalc,
        currentBatteryPercent,
        targetChargePercent,
        stationPowerKW,
        {
          ambientTemp: 20,
          batteryCondition: 'good',
          chargingStrategy: 'balanced'
        }
      );
      
      // ≈ûarj duraƒüƒ±nƒ± ekle
      const chargingStop: ChargingStop = {
        stationId: bestStation.station.ID,
        name: bestStation.station.AddressInfo?.Title || `ƒ∞stasyon ${bestStation.station.ID}`,
        stopCoord: {
          latitude: bestStation.station.AddressInfo?.Latitude || 0,
          longitude: bestStation.station.AddressInfo?.Longitude || 0
        },
        distanceFromStartKm: Math.round(traveledDistanceKm),
        batteryBeforeStopPercent: Math.round(currentBatteryPercent),
        batteryAfterStopPercent: Math.round(targetChargePercent),
        energyChargedKWh: Math.round(energyToChargeKWh * 10) / 10,
        estimatedChargeTimeMinutes: chargingResult.timeMinutes,
        stationPowerKW: Math.round(stationPowerKW),
        connectorType: selectedVehicle.socketType,
        averageChargingPowerKW: Math.round(chargingResult.averagePowerKW * 10) / 10,
        chargingEfficiency: Math.round(chargingResult.efficiency),
        segmentInfo: {
          segmentIndex: segmentIndex + 1,
          distanceToNext: remainingDistanceKm,
          batteryAtSegmentEnd: Math.round(currentBatteryPercent)
        }
      };
      
      chargingStops.push(chargingStop);
      usedStationIds.add(bestStation.station.ID);
      
      // Durum g√ºncelle
      currentBatteryPercent = targetChargePercent;
      currentBatteryKWh = (currentBatteryPercent / 100) * selectedVehicle.batteryCapacity;
      currentRangeKm = (currentBatteryKWh * 100) / selectedVehicle.consumption;
      
      console.log(`‚ö° ≈ûarj duraƒüƒ± eklendi:`, {
        station: chargingStop.name,
        distance: `${chargingStop.distanceFromStartKm}km`,
        batteryChange: `${chargingStop.batteryBeforeStopPercent}% ‚Üí ${chargingStop.batteryAfterStopPercent}%`,
        chargeTime: `${chargingStop.estimatedChargeTimeMinutes}dk`,
        newRange: `${currentRangeKm.toFixed(1)}km`
      });
    }
    
    segmentIndex++;
  }
  
  // [7] üìä Final hesaplamalar
  const totalChargingTimeMinutes = chargingStops.reduce((total, stop) => total + stop.estimatedChargeTimeMinutes, 0);
  const canReachDestination = remainingDistanceKm <= 0;
  
  // Hedefte kalan batarya hesapla
  let finalBatteryPercent = currentBatteryPercent;
  if (remainingDistanceKm > 0) {
    const remainingEnergyKWh = (remainingDistanceKm * selectedVehicle.consumption) / 100;
    finalBatteryPercent = currentBatteryPercent - (remainingEnergyKWh / selectedVehicle.batteryCapacity * 100);
  }

  // üìä ≈ûarj verimliliƒüi istatistikleri hesapla
  const totalEnergyCharged = chargingStops.reduce((total, stop) => total + stop.energyChargedKWh, 0);
  const totalNominalCharging = chargingStops.reduce((total, stop) => 
    total + (stop.stationPowerKW * (stop.estimatedChargeTimeMinutes / 60)), 0);
  const averageChargingPower = chargingStops.length > 0 ? 
    chargingStops.reduce((total, stop) => total + (stop.averageChargingPowerKW || stop.stationPowerKW), 0) / chargingStops.length : 0;
  const overallChargingEfficiency = totalNominalCharging > 0 ? (totalEnergyCharged / totalNominalCharging) * 100 : 0;

  // üìç Segment bazlƒ± SOC hesaplamasƒ±
  const segmentDistances: number[] = [];
  const segmentDescriptions: string[] = [];
  
  // ƒ∞lk segment - ba≈ülangƒ±√ßtan ilk ≈üarj duraƒüƒ±na
  if (chargingStops.length > 0) {
    segmentDistances.push(chargingStops[0].distanceFromStartKm);
    segmentDescriptions.push(`Ba≈ülangƒ±√ß ‚Üí ${chargingStops[0].name}`);
    
    // ≈ûarj duraklarƒ± arasƒ± segmentler
    for (let i = 1; i < chargingStops.length; i++) {
      const segmentDistance = chargingStops[i].distanceFromStartKm - chargingStops[i-1].distanceFromStartKm;
      segmentDistances.push(segmentDistance);
      segmentDescriptions.push(`${chargingStops[i-1].name} ‚Üí ${chargingStops[i].name}`);
    }
    
    // Son segment - son ≈üarj duraƒüƒ±ndan hedefe
    const lastStopDistance = chargingStops[chargingStops.length - 1].distanceFromStartKm;
    const finalSegmentDistance = routeDistanceKm - lastStopDistance;
    if (finalSegmentDistance > 0) {
      segmentDistances.push(finalSegmentDistance);
      segmentDescriptions.push(`${chargingStops[chargingStops.length - 1].name} ‚Üí Hedef`);
    }
  } else {
    // Hi√ß ≈üarj duraƒüƒ± yoksa tek segment
    segmentDistances.push(routeDistanceKm);
    segmentDescriptions.push('Ba≈ülangƒ±√ß ‚Üí Hedef (Tek segment)');
  }

  const segmentDetails = energyCalc.calculateSegmentSOC(startChargePercent, segmentDistances, segmentDescriptions);

  console.log('üèÅ ≈ûarj planƒ± tamamlandƒ±:', {
    canReachDestination,
    chargingStops: chargingStops.length,
    finalBattery: `${finalBatteryPercent.toFixed(1)}%`,
    totalChargingTime: `${totalChargingTimeMinutes}dk`,
    warnings: warnings.length
  });

  return {
    chargingStops,
    totalChargingTimeMinutes,
    canReachDestination,
    batteryAtDestinationPercent: Math.round(finalBatteryPercent),
    totalEnergyConsumedKWh: Math.round(totalEnergyNeededKWh * 10) / 10,
    warnings,
    segmentDetails,
    chargingEfficiencyStats: {
      averageChargingPower: Math.round(averageChargingPower * 10) / 10,
      totalEnergyCharged: Math.round(totalEnergyCharged * 10) / 10,
      chargingEfficiency: Math.round(overallChargingEfficiency)
    }
  };
}

/**
 * üìñ KULLANIM √ñRNEƒûƒ∞:
 * 
 * ```typescript
 * import { generateChargingPlan } from '../utils/chargingPlanCalculator';
 * import { useVehicleStore } from '../context/useVehicleStore';
 * 
 * // RouteDetailScreen veya ba≈üka bir component i√ßinde:
 * const { getSelectedVehicle } = useVehicleStore();
 * const selectedVehicle = getSelectedVehicle();
 * 
 * const routeData = {
 *   distance: 606100, // meters (606.1km)
 *   polylinePoints: [
 *     { latitude: 36.8969, longitude: 30.7133 },
 *     { latitude: 37.0000, longitude: 31.0000 },
 *     // ... more points
 *   ]
 * };
 * 
 * const chargingPlan = generateChargingPlan({
 *   selectedVehicle,
 *   routeData,
 *   chargingStations: availableStations
 * });
 * 
 * console.log('üîã ≈ûarj Planƒ±:');
 * console.log(`Toplam Durak: ${chargingPlan.chargingStops.length}`);
 * console.log(`Toplam ≈ûarj S√ºresi: ${chargingPlan.totalChargingTimeMinutes} dakika`);
 * console.log(`Hedefe Ula≈üabilir: ${chargingPlan.canReachDestination ? 'Evet' : 'Hayƒ±r'}`);
 * console.log(`Hedefteki Batarya: ${chargingPlan.batteryAtDestinationPercent}%`);
 * 
 * chargingPlan.chargingStops.forEach((stop, index) => {
 *   console.log(`Durak ${index + 1}: ${stop.name}`);
 *   console.log(`  üìç Mesafe: ${stop.distanceFromStartKm}km`);
 *   console.log(`  üîã Batarya: ${stop.batteryBeforeStopPercent}% ‚Üí ${stop.batteryAfterStopPercent}%`);
 *   console.log(`  ‚è±Ô∏è ≈ûarj S√ºresi: ${stop.estimatedChargeTimeMinutes} dakika`);
 *   console.log(`  ‚ö° G√º√ß: ${stop.stationPowerKW}kW`);
 * });
 * ```
 * 
 * ‚ö†Ô∏è √ñNEMLƒ∞ NOTLAR:
 * 
 * 1. **Vehicle Store Entegrasyonu**: selectedVehicle mutlaka Vehicle tipinde olmalƒ± ve ≈üu √∂zellikleri i√ßermeli:
 *    - batteryCapacity (kWh)
 *    - consumption (kWh/100km) 
 *    - socketType ('CCS', 'Type2', 'CHAdeMO')
 * 
 * 2. **Route Data Format**: routeData.polylinePoints Google Directions API'den gelen decoded polyline olmalƒ±
 * 
 * 3. **Charging Stations**: OpenChargeMap API'den gelen tam ChargingStation[] array'i gerekli
 * 
 * 4. **Performance**: B√ºy√ºk rotalar i√ßin (1000+ nokta) polylinePoints'i optimize etmek gerekebilir
 * 
 * 5. **Error Handling**: Eƒüer uygun istasyon bulunamazsa warnings array'inde uyarƒ±lar olacak
 */

/**
 * üîß YARDƒ∞MCI FONKSƒ∞YONLAR:
 */

// ≈ûarj planƒ±nƒ± UI-friendly formatta format et
export function formatChargingPlanForUI(plan: ChargingPlanResult) {
  return {
    summary: {
      totalStops: plan.chargingStops.length,
      totalChargingTime: `${Math.floor(plan.totalChargingTimeMinutes / 60)}s ${plan.totalChargingTimeMinutes % 60}dk`,
      canReach: plan.canReachDestination,
      finalBattery: `${plan.batteryAtDestinationPercent}%`,
      totalEnergy: `${plan.totalEnergyConsumedKWh}kWh`,
      hasWarnings: plan.warnings.length > 0
    },
    stops: plan.chargingStops.map((stop, index) => ({
      number: index + 1,
      name: stop.name,
      location: `${stop.distanceFromStartKm}km'de`,
      batteryChange: `${stop.batteryBeforeStopPercent}% ‚Üí ${stop.batteryAfterStopPercent}%`,
      chargeTime: `${stop.estimatedChargeTimeMinutes}dk`,
      power: `${stop.stationPowerKW}kW`,
      connector: stop.connectorType,
      coordinates: stop.stopCoord
    })),
    warnings: plan.warnings
  };
}

// ≈ûarj planƒ± validasyonu
export function validateChargingPlan(
  vehicle: Vehicle,
  routeData: RouteData,
  stations: ChargingStation[]
): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Vehicle validation
  if (!vehicle.batteryCapacity || vehicle.batteryCapacity < 10 || vehicle.batteryCapacity > 200) {
    errors.push('Batarya kapasitesi 10-200 kWh arasƒ±nda olmalƒ±dƒ±r');
  }
  
  if (!vehicle.consumption || vehicle.consumption < 10 || vehicle.consumption > 50) {
    errors.push('T√ºketim 10-50 kWh/100km arasƒ±nda olmalƒ±dƒ±r');
  }
  
  if (!['CCS', 'Type2', 'CHAdeMO'].includes(vehicle.socketType)) {
    errors.push('Desteklenmeyen soket tipi');
  }
  
  // Route validation
  if (!routeData.distance || routeData.distance < 1000) {
    errors.push('Rota mesafesi minimum 1km olmalƒ±dƒ±r');
  }
  
  if (!routeData.polylinePoints || routeData.polylinePoints.length < 2) {
    errors.push('Rota en az 2 koordinat noktasƒ± i√ßermelidir');
  }
  
  // Stations validation
  if (!stations || stations.length === 0) {
    errors.push('≈ûarj istasyonu bulunamadƒ±');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

// Geli≈ümi≈ü ≈üarj s√ºresi hesaplama (Yeni energyUtils kullanarak)
function calculateAdvancedChargeTime(
  energyCalculator: EnergyCalculator,
  startSOC: number,
  targetSOC: number,
  stationPowerKW: number,
  options: {
    ambientTemp?: number;
    batteryCondition?: 'new' | 'good' | 'fair' | 'poor';
    chargingStrategy?: 'fast' | 'balanced' | 'gentle';
  } = {}
): { timeMinutes: number; averagePowerKW: number; efficiency: number } {
  const chargingSession = energyCalculator.calculateAdvancedChargingCurve(
    startSOC,
    targetSOC,
    stationPowerKW,
    {
      ambientTempC: options.ambientTemp || 20, // Default 20¬∞C
      batteryCondition: options.batteryCondition || 'good',
      chargingStrategy: options.chargingStrategy || 'balanced'
    }
  );

  const efficiency = (chargingSession.averageChargingPowerKW / stationPowerKW) * 100;

  return {
    timeMinutes: chargingSession.chargingTimeMinutes,
    averagePowerKW: chargingSession.averageChargingPowerKW,
    efficiency
  };
}

// Legacy ≈üarj s√ºresi hesaplama (geriye uyumluluk i√ßin)
function calculateChargeTime(
  energyToChargeKWh: number, 
  stationPowerKW: number,
  currentBatteryPercent: number,
  targetBatteryPercent: number
): number {
  // ≈ûarj eƒürisi sim√ºlasyonu - y√ºksek batarya seviyelerinde ≈üarj yava≈ülar
  let averageChargingPower = stationPowerKW;
  
  if (currentBatteryPercent > 80) {
    averageChargingPower *= 0.3; // %80 √ºzerinde √ßok yava≈ü
  } else if (currentBatteryPercent > 60) {
    averageChargingPower *= 0.6; // %60-80 arasƒ± yava≈ülar
  } else if (currentBatteryPercent > 40) {
    averageChargingPower *= 0.8; // %40-60 arasƒ± biraz yava≈ü
  }
  // %0-40 arasƒ± maksimum hƒ±zda ≈üarj
  
  const chargeTimeHours = energyToChargeKWh / averageChargingPower;
  return Math.round(chargeTimeHours * 60); // Dakikaya √ßevir
} 